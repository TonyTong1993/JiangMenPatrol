package com.zzz.ecity.android.applibrary.database;

import java.util.ArrayList;
import java.util.List;

import com.ecity.android.db.Database;
import com.ecity.android.db.exception.Z3DBException;
import com.ecity.android.db.model.ASQLiteBean;
import com.ecity.android.db.model.DBRecord;
import com.ecity.android.db.model.DBRecordSet;
import com.ecity.android.db.utils.StringUtil;
import com.zzz.ecity.android.applibrary.MyApplication;
import com.zzz.ecity.android.applibrary.utils.ListUtil;

public abstract class ABaseDao<T extends ASQLiteBean> {
    private String tableName = getTableName();
    private Database db;
    private Database getDatabase(){
    	try {
			if(null == db || !db.getDatabase().isOpen()){
				if(null != db){
					db.closeDatabase();
				}
				
				db = MyApplication.getApplication().getDatabase(getTableName());
			}
		} catch (Z3DBException e) {
			e.printStackTrace();
		}
        return db;
    }
    /**
     * @param where where the condition to query with, for example 'id < 5 and status = ?'.
     * @param parameterValues values for ? in where
     * @return
     */
    public List<T> queryList(String where, String[] parameterValues) throws IllegalAccessException {
        List<T> list = new ArrayList<T>();
        try {
            String sql = "select * from " + tableName + " ";
            if (!StringUtil.isBlank(where)) {
                sql = sql + " where " + where;
            }
            
            DBRecordSet recordSet = null;
            try {
                recordSet = getDatabase().query(sql, parameterValues, getBeanClass().newInstance());
            } catch (Exception e) {
                e.printStackTrace();
            }
            if ((recordSet != null) && (recordSet.getRecords().length > 0)) {
                DBRecord[] records = recordSet.getRecords();
                for (DBRecord record : records) {
                    if (checkRecordType(record)) {
                        @SuppressWarnings("unchecked")
                        T bean = (T) record.getBean();
                        list.add(bean);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return list;
    }

    /**
     * 
     * @param where the condition to query with, for example 'id < 5'.
     * @return
     */
    public List<T> queryList(String where) {
        try {
            return queryList(where, null);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * @param where where the condition to query with, for example 'id < 5 and status = ?'.
     * @param parameterValues values for ? in where
     * @return
     */
    public T queryOne(String where, String[] parameterValues) {
        List<T> list = null;
        try {
            list = queryList(where, parameterValues);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        return ListUtil.isEmpty(list) ? null : list.get(0);
    }

    public T queryOne(String where) {
        List<T> list = queryList(where);

        return ListUtil.isEmpty(list) ? null : list.get(0);
    }

    /**
     * Insert a new bean.
     * @param bean the bean to insert
     * @return If the bean has been inserted successfully, return id of the bean generated by db. If the bean has existed, return 0
     */
    public long insert(T bean) {
        String where = getCheckExistenceWhereBeforeInsert(bean);
        if (!StringUtil.isBlank(where)) {
            List<T> list = queryList(where);
            if (!ListUtil.isEmpty(list)) {
                return 0;
            }
        }

        try {
            return getDatabase().insert(tableName, bean);
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        return -1;
    }

    public void update(T bean, String where) {
        try {
            getDatabase().update(tableName, bean, where);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void delete(String where) {
        try {
            getDatabase().delete(tableName, where);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public int getMaxID() {
        try {
            return getDatabase().getMaxID(tableName);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return -1;
    }
    
    public int getRecordCount(String where) {
        try {
            return getDatabase().getRecordCount(tableName, where);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return -1;
    }

    public void execute(String sql) {
        try {
            getDatabase().execSQL(sql);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**
     * @return Name of the table to execute against.
     */
    protected abstract String getTableName();

    /**
     * The the type of returned record when run 
     * {@link ABaseDao#queryList(String, Class)}.<br>
     * Not sure if this check is necessary, just a double check.<br>
     * A standard implementation is(using WorkerBeanXtd as an example) <br>
     * protected boolean checkRecordType(DBRecord record) {<br>
     * &nbsp&nbsp&nbsp&nbspreturn (record == null) ? false : (record.getBean() instanceof WorkerBeanXtd);<br>
     * }<br>
     * @param record
     * @return
     */
    protected abstract boolean checkRecordType(DBRecord record);

    /**
     * @return bean class that current dao is responsible for
     */
    protected abstract Class<T> getBeanClass();

    /**
     * @param bean the bean to insert
     * @return the where clause to check record existence before inserting a new bean.
     */
    protected abstract String getCheckExistenceWhereBeforeInsert(T bean);
}
